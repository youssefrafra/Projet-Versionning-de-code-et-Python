# -*- coding: utf-8 -*-
"""Exceptions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nVU6M-n6rJYJIm8Az8BOFddAqU-_7BEH
"""

def calc_fibonacci(n): #### Création de la fonction qui calculera la série de Fibonacci
  result = [0,1]
  for i in range(2, n + 1):
    next = result[-1] + result[-2]
    result.append(next)
  result = ", ".join([str(i) for i in result])
  print(f"La suite fibonacci est :\n {result}")

def longuer_depasse(n, limite = 3):
  #### Si le nombre de digit est > à la limite alors 
  if len(str(n)) > limite  : #### SI la longeur de la valeur numérique et stictement > à la limite
    print(f"Le nombre {n} comporte plus de {limite} chiffre, Veuillez resaisir avec un nombre de chiffres <= {limite}")
    return True
  return False

def fibonacci(n):#### Création de la fonction fibonacci
  #### Variable en entrée: int positif

  #############################
  #### Cas 1: Chaine de caractère
  #################################
  if (type(n)==str):
    print("Impossibilité de saisir un string dans la fonction")
    print("Veuillez saisir une valeur numérique")
    return
  ###################################
  #### Cas 2: Complexe
  ###################################
  elif (type(n) == complex):
    n = round(abs(n.real)) #### On prend l'entier le plus proche de la valeur absolue de la partie réelle de n pour gérer le cas du Float
                           #### et on réaffecte la valeur de n avec
    print("Le nombre fourni est un complexe")
    print(f"La valeur entière la plus proche de la valeur absolue de sa partie réelle est prise, dans ce cas: n = {n}")
    if longuer_depasse(n, 3): return ### vérifier la longuer de n avant le calcul 
                                     ### et on sort de la fonction si la longeur dépasse la limite
    calc_fibonacci(n)
  
  ###################################
  #### Cas 3: Float 
  ###################################
  elif type(n) == float:
      n = round(n) ### On prend l'entier le plus proche de la valeur
      print("Le nombre fourni est un float")
      print(f"La valeur entière la plus proche est prise, dans ce cas: n = {n}")
      if longuer_depasse(n, 3): return ### vérifier la longuer de n avant le calcul 
                                       ### et on sort de la fonction si la longeur dépasse la limite
      if n < 0:
        print("Le nombre fourni est négatif")
        print("La valeur absolue est prise, dans ce cas: n= {n}")
        n = abs(n) #### Varaible a (valeur absolue)
      return calc_fibonacci(n)

  ###################################
  #### Cas 4: Entier Négatif
  ###################################
  elif type(n) == int:
    if n < 0: ## Cas où n est négatif
      if longuer_depasse(n, 3): return ### vérifier la longuer de n avant le calcul 
                                       ### et on sort de la fonction si la longeur dépasse la limite
      n = abs(n) #### Variable n en valeur absolue
      print("Le nombre fourni est négatif")
      print(f"La valeur absolue est prise, dans ce cas: n = {n}")
      return calc_fibonacci(n)
    if longuer_depasse(n, 3): return ### vérifier la longuer de n avant le calcul 
                                     ### et on sort de la fonction si la longeur dépasse la limite
    return calc_fibonacci(n) #### Si n est un entier naturel de longueur acceptable

fibonacci(55.5 + 5j)

fibonacci(' ')

fibonacci(-5)